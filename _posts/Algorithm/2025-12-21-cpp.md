---
title: "排序算法"
published: false
categories:
  -
tags:
  -
---


- & | ~ ^：与 或 非 异
- 算数 关系 位运算

函数默认是extern的，变量不加extern就是重新定义，加了static只能在当前文件里用
匿名命名空间功能一样里边的东西只能本文件内使用，有很多变量的时候更简洁
inline相比#define有类型检查更安全


```cpp
#include <iostream>

int a = 1;

namespace O {
    namespace I {
        int a = 3;
    }
}

namespace O {
    int a = 2;
}

using namespace O;

int main() {
    int a;
    a = 4;
    std::cout << a;
    std::cout << ::a;
    std::cout << O::I::a;
    std::cout <<O::a;
    return 0;
}
```

你爸的朋友不一定是你的朋友，友元不会被继承
```cpp
class A{};

class B{
    friend class A;
    friend class C;
    friend A;
    friend C; // X 不知道C是什么
};

class C{};

int main() {}
```

类的成员变量按照类里声明的顺序，不管初始化列表是什么顺序，析构是从后往前

```cpp
Student() = default; // 生成默认构造函数
Student::Student() : Student(1, 2) {} // 委托其他实现
explicit Student(int age); // void foo(Student); foo(3); 会隐式创建一个Student对象，加了explicit拒绝这种隐式创建
Student(char id) = delete; // 不允许char类型被提升成int，直接编译报错
```
explicit只能修饰单参构造函数，不会被继承

不定义拷贝构造函数默认生成浅拷贝，指向同一个内存，一个释放另一个继续用是未定义行为
- Clazz(const Clazz& clazz) 拷贝
- Clazz(Clazz&& clazz) 移动

```cpp
Test& operator=(const Test& rhs)
void* operator new() {}
void operator delete(void*){}
```
,是从左到右计算的

前向定义只能引用，看不到定义不能操作属性

```cpp
#include <iostream>

struct N{
    N& operator,(N& rhs) {
        std::cout<< rhs.num<<" ";
        return rhs;
    }
    explicit N(int n): num(n) {}
    N() = default;
        int num;
};

int main() {
    N a(1), b(2), c(3), d;
    d = (a, b, c); // This will print: 1 2

    std::cout<<d.num<<std::endl;
    return 0;
}
```

构造默认不被继承，using Base::Base继承，多个重载实现了一个其他的都不可见，其他的也用过using继承。析构不能继承，字类析构会先调父类的析构

只有标了virtual的函数才有多态，override会检查基类是不是有虚函数，标了final的函数不能往下继续多态
虚函数表每个类型一份，每个对象指过去。虚表在父类构造完，字类初始化列表执行之前构造，父类的构造和析构里引用都是父类的
函数 =0 是纯虚函数，有纯虚函数的类不能实例化

RAII：在构造函数中申请，在析构函数中释放，出对象生命周期就会清理资源，避免了泄漏

回栈导致大量cache miss，降低执行性能

static_cast：编译时转换，没有运行时动态检查，下行转换不安全
dynamic_cast：只能转成指针或引用，指针转失败返回空，引用转失败抛异常
const_cast：
reinterpret_cast：拿着地址用新的类型重新解释

模版类/函数按需生成，是不同的定义，不是运行时动态的
可变模版类型递归展开，定义一个终止实现

左值：表达式运行结束仍然存在
右值：表达式结束后就没了，不能修改
- 纯右值：没有地址的临时变量
- 将亡值：有地址但是这个表达式结束就没了，里面有可以复用的资源

std::move将左值转为右值，clazz& 左值引用，clazz&& 右值引用
- 左值不能赋给右值引用
- 右值可以赋给常量左值引用
- 右值引用的值可以操作
- 右值引用本身是一个左值
  - 完美转发：模版类中 T&& 传的是左值引用就是左值引用，传的是右值引用就是右值引用。std::forward<T>(v)转发的是原来是什么就是什么

```cpp
#include <utility>
#include <iostream>
int main() {
    const int& clr = std::move(1);
    int&& rr = std::move(2);
    rr += clr;
    std::cout<<rr; // 3
    return 0;
}
```

lambda默认参数是const的，参数auto类似泛型可以接多种类型
作用域里的static变量可以直接
闭包：函数拥有数据，数据封闭在函数体内
std::function<return_type(parameter_type)> 可以代表任何可调用的对象

std::initializer_list<type> 接一 {} 任意个数同一类型的值，里面的值不能修改，开销很低 

```cpp
#include <iostream>
#include <initializer_list>
#include <vector>

class D {
public:
    int num;
    D(int n): num(n) { std::cout << "construct " << num << std::endl; }
    D(const D& d): num(d.num) { std::cout << "copy construct " << num << std::endl; }
    ~D() { std::cout << "destruct" << num << std::endl; }
};

class C {
    std::vector<D> list;
public:
    C( std::initializer_list<D> lst ): list(lst) { std::cout << "container" << std::endl; }
    ~C() { 
        for (auto &d: list) std::cout << d.num << std::endl; 
    }
};

int main() {
    {
        C c = {{ 1, 2 }}; // 初始化列表的生命周期只在19行
        std::cout << "in main" << std::endl;
    }
    return 0;
}

construct 1
construct 2
copy construct 1
copy construct 2
container
destruct2
destruct1
in main
1
2
destruct2
destruct1
```

内存模型
- sequential consistency：1. 处理器内执行顺序和代码顺序一致 2. 处理器间内存是单核的
- tatal store ordering：放松2，结果写到cache就可以继续
- relaxed memory model：继续放松1，只要单核结果正确就行

- acquire-release：不管变量是不是相关都不能乱序
  - memory_order_acquire：修饰读，我读完了才能继续
  - memory_order_release：修饰写，大家都干完了我才写
  - memory_order_acq_rel：包含前两个
- release-consume：只保证数据相关的指令顺序，其他的随便乱序
- relaxed：只保证同一个变量的多行代码按顺序

类型推倒
- auto不保留const，auto带ref保留const
- ref ref都能推倒成左值或右值引用